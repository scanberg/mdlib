#version 460

#include "common.h"

layout (binding = POSITION_BINDING, std430) readonly buffer PositionBuffer {
	Position positions[];
};

layout (binding = GROUP_BINDING, std430) readonly buffer GroupBuffer {
	Group groups[];
};

layout (binding = DRAW_OP_BINDING, std430) readonly buffer InputDrawOperations {
	DrawOp ops[];
};

layout (binding = DRAW_INDIRECT_BINDING, std430) buffer DrawIndirectBuffer {
	DrawIndirect indirect;
};

layout (binding = DRAW_SPHERE_INDEX_BINDING, std430) buffer DrawSphereIndices {
	uint sphere_indices[];
};

layout (local_size_x = CULL_GROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

shared uint total_write_count = 0;
shared uint total_write_offset = 0;

void main() {
	uint draw_idx = gl_WorkGroupID.x;
	uint group_idx = gl_LocalInvocationID.x;

	if (group_idx == 0) {
		total_write_count = 0;
		total_write_offset = 0;
	}

	if (group_idx < ops[draw_idx].group_count) {
		uint group_write_offset = 0;
		uint group_atom_offset = groups[ops[draw_idx].group_offset + group_idx].atom_offset;
		uint group_atom_count  = groups[ops[draw_idx].group_offset + group_idx].atom_count;

		// Compute AABB
		vec3 aabb_min = +vec3(INF,INF,INF);
		vec3 aabb_max = -vec3(INF,INF,INF);
		for (uint j = group_atom_offset; j < group_atom_offset + group_atom_count; ++j) {
			uint idx = ops[draw_idx].atom_offset + j;
			vec3 pos = vec3(positions[idx].x, positions[idx].y, positions[idx].z);
			aabb_min = min(aabb_min, pos);
			aabb_max = max(aabb_max, pos);
		}

		// Frustum Culling

		// Compute Min Max Clip Coords from AABB

		// Determine LOD from Clip Extent

		// Cull using Hi-Z texture

		bool group_visible = true;
		if (group_visible) {
			group_write_offset = atomicAdd(total_write_count, group_atom_count);
		}

		// SYNC
		barrier();

		if (group_idx == 0) {
			atomicAdd(indirect.draw_sphere_cmd_count, 1);

			total_write_offset = atomicAdd(indirect.sphere_idx_count, total_write_count);

			indirect.draw_sphere_cmd[draw_idx].cmd.count = total_write_count;
			indirect.draw_sphere_cmd[draw_idx].cmd.instance_count = 1;
			indirect.draw_sphere_cmd[draw_idx].cmd.first = total_write_offset;
			indirect.draw_sphere_cmd[draw_idx].cmd.base_instance = 0;

			indirect.draw_sphere_cmd[draw_idx].transform_idx = ops[draw_idx].transform_idx;
			indirect.draw_sphere_cmd[draw_idx].atom_offset   = ops[draw_idx].atom_offset;
			indirect.draw_sphere_cmd[draw_idx].color_offset  = ops[draw_idx].color_offset;
			indirect.draw_sphere_cmd[draw_idx].radius_scale  = ops[draw_idx].rep_args[0];
		}

		barrier();

		if (group_visible) {
			for (uint j = 0; j < group_atom_count; ++j) {
				// Write structure relative offsets
				sphere_indices[total_write_offset + group_write_offset + j] = group_atom_offset + j;
			}
		}
	}
}