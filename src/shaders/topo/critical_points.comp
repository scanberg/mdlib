#version 450

#define WG_X 8
#define WG_Y 8
#define WG_Z 8
#define WG_SIZE (WG_X * WG_Y * WG_Z)

#define SG_X (WG_X + 2)
#define SG_Y (WG_Y + 2)
#define SG_Z (WG_Z + 2)
#define SG_SIZE (SG_X * SG_Y * SG_Z)

#define REGULAR 0
#define MAXIMUM 1
#define SPLIT_SADDLE 2
#define MINIMUM 3
#define JOIN_SADDLE 4

#define NUM_NEIGHBORS 26

layout(local_size_x = WG_X, local_size_y = WG_Y, local_size_z = WG_Z) in;

// UBO data (shared across all shaders)
layout(std140, binding = 0) uniform UBO {
    mat4 index_to_world;
    uvec3 dims;
    float scalar_threshold;
};

// Input volume texture
layout(binding = 0, r32f) uniform readonly image3D volumeTex;

layout(std430, binding = 1) readonly buffer AscendingManifold {
    uint ascending[];
};

layout(std430, binding = 2) readonly buffer DescendingManifold {
    uint descending[];
};

// Output buffers
layout(std430, binding = 3) writeonly buffer CriticalPointTypes {
    int types[];
};

layout (std430, binding = 4) buffer CriticalPointCounts {
    uint maximaCount;
    uint splitSaddleCount;  // saddles in ascending manifold
    uint minimaCount;
    uint joinSaddleCount;   // saddles in descending manifold
};

bool is_valid_voxel(ivec3 ijk) {
    return all(greaterThanEqual(ijk, ivec3(0))) && all(lessThan(ijk, ivec3(dims)));
}

// Helper functions
float get_scalar(ivec3 ijk) {
    if (!is_valid_voxel(ijk)) {
        return 0; // Guard against out-of-bounds
    }
    return imageLoad(volumeTex, ijk).r;
}

uint get_voxel_id(ivec3 ijk) {
    if (!is_valid_voxel(ijk)) {
        return 0xFFFFFFFFu;
    }
    return uint(ijk.x + ijk.y * dims.x + ijk.z * dims.x * dims.y);
}

bool sos_is_greater(float value_a, uint id_a, float value_b, uint id_b) {
    return (value_a > value_b) || (value_a == value_b && id_a > id_b);
}

// Explicit neighbor offsets for 26-connectivity
const ivec3 neighbor_offset[NUM_NEIGHBORS] = ivec3[](
    ivec3(-1, -1, -1), ivec3(0, -1, -1), ivec3(1, -1, -1),
    ivec3(-1, 0, -1),  ivec3(0, 0, -1),  ivec3(1, 0, -1),
    ivec3(-1, 1, -1),  ivec3(0, 1, -1),  ivec3(1, 1, -1),
    
    ivec3(-1, -1, 0),  ivec3(0, -1, 0),  ivec3(1, -1, 0),
    ivec3(-1, 0, 0),                     ivec3(1, 0, 0),
    ivec3(-1, 1, 0),   ivec3(0, 1, 0),   ivec3(1, 1, 0),
    
    ivec3(-1, -1, 1),  ivec3(0, -1, 1),  ivec3(1, -1, 1),
    ivec3(-1, 0, 1),   ivec3(0, 0, 1),   ivec3(1, 0, 1),
    ivec3(-1, 1, 1),   ivec3(0, 1, 1),   ivec3(1, 1, 1)
);

// Precomputed adjacency masks for 26 neighbors (bit i set if neighbor i is adjacent)
const uint neighbor_adjacency_mask[NUM_NEIGHBORS] = {
    0x0000161A,
    0x00003E3D,
    0x00002C32,
    0x0000D6D3,
    0x0001FFEF,
    0x0001AD96,
    0x0000D098,
    0x0001F178,
    0x0001A0B0,
    0x0036141B,
    0x007E3A3F,
    0x006C2436,
    0x01B6C6DB,
    0x036D8DB6,
    0x01B090D8,
    0x03F171F8,
    0x0360A1B0,
    0x00341600,
    0x007A3E00,
    0x00642C00,
    0x01A6D600,
    0x03DFFE00,
    0x032DAC00,
    0x0130D000,
    0x02F1F000,
    0x0161A000,
};

// Count link components using bitmask and static adjacency
int count_link_components(uint link_mask) {
    if (link_mask == 0u) return 0;

    uint mask = link_mask;
    int num_components = 0;
    // Count unvisited components
    for (int start = 0; start < NUM_NEIGHBORS; ++start) {
        uint bit = 1u << start;
        if ((mask & bit) == 0u) continue;
        num_components++;

        // Bitwise flood-fill
        uint component = bit;
        uint prev = 0u;
        while (component != prev) {
            prev = component;
            for (int nb = 0; nb < NUM_NEIGHBORS; ++nb) {
                if ((component & (1u << nb)) != 0u) {
                    component |= neighbor_adjacency_mask[nb] & link_mask;
                }
            }
        }
        mask &= ~component;
    }

    return num_components;
}


// Shared memory for workgroup-local compaction
shared uint numMaxima;
shared uint numSplitSaddles;
shared uint numMinima;
shared uint numJoinSaddles;
shared uint numEdges;

// Shared memory for scalar values and voxel IDs in a 10x10x10 region (8x8x8 block + 1 padding in each direction)
shared float sharedScalars[SG_X][SG_Y][SG_Z];
shared uint sharedIds[SG_X][SG_Y][SG_Z];

void main() {
    // Compute global voxel index from 3D thread indices
    uvec3 gid = gl_GlobalInvocationID.xyz;
    if (any(greaterThanEqual(gid, dims))) {
        return;
    }
    uint voxel_id = gid.x + gid.y * dims.x + gid.z * dims.x * dims.y;

    // Initialize shared memory for counters
    if (gl_LocalInvocationIndex == 0) {
        numMaxima = 0u;
        numSplitSaddles = 0u;
        numMinima = 0u;
        numJoinSaddles = 0u;
        numEdges = 0u;
    }
    // Ensure all threads see the zeroed counters before proceeding
    barrier();

    // Compute local indices in shared memory (with +1 padding)
    ivec3 local_idx = ivec3(gl_LocalInvocationID.x + 1, gl_LocalInvocationID.y + 1, gl_LocalInvocationID.z + 1);
    ivec3 global_idx = ivec3(gid);

    ivec3 dims_i = ivec3(dims);

    // Cooperative linear fill of the 10x10x10 shared region (covers centers + padding)
    {
        // Use compile-time workgroup size constants to avoid driver compiler issues
        int tid = int(gl_LocalInvocationIndex);

        // Block origin in voxel coordinates (position of the thread (0,0,0) in this WG)
        ivec3 block_origin = ivec3(gl_WorkGroupID) * ivec3(WG_X, WG_Y, WG_Z) - ivec3(1,1,1);
        for (int s = tid; s < SG_SIZE; s += WG_SIZE) {
            int sx = s % SG_X;
            int sy = (s / SG_X) % SG_Y;
            int sz = s / (SG_X * SG_Y);

            // map shared slot to global voxel: block_origin + (sx-1, sy-1, sz-1)
            ivec3 gp = block_origin + ivec3(sx, sy, sz);
            bool is_valid = is_valid_voxel(gp);
            gp = clamp(gp, ivec3(0), dims_i - 1);

            sharedScalars[sx][sy][sz] = imageLoad(volumeTex, gp).r;
            int lin = gp.x + gp.y * dims_i.x + gp.z * dims_i.x * dims_i.y;
            sharedIds[sx][sy][sz] = is_valid ? uint(lin) : 0xFFFFFFFFu;
        }
    }

    barrier();

    float fi = sharedScalars[local_idx.x][local_idx.y][local_idx.z];
    int type = REGULAR;

    if (scalar_threshold < fi) {
        // Get all neighbors using shared memory
        uint  neighbor_ids[NUM_NEIGHBORS];
        float neighbor_scalars[NUM_NEIGHBORS];
        uint  neighbor_mask = 0u;
        for (int i = 0; i < NUM_NEIGHBORS; i++) {
            ivec3 offset = neighbor_offset[i];
            ivec3 n = local_idx + offset;
            neighbor_ids[i] = sharedIds[n.x][n.y][n.z];
            neighbor_scalars[i] = sharedScalars[n.x][n.y][n.z];
            neighbor_mask |= (neighbor_ids[i] != 0xFFFFFFFFu) ? (1u << i) : 0u;
        }
        
        // ===== Analyze ASCENDING manifold (maxima + split saddles) =====
        uint reachable_maxima[NUM_NEIGHBORS];
        int  reachable_maxima_count = 0;
        uint upper_link_mask = 0u;
        
        for (int i = 0; i < NUM_NEIGHBORS; i++) {
            uint n_id = neighbor_ids[i];
            if (n_id == 0xFFFFFFFFu) continue;
            float n_scalar = neighbor_scalars[i];
            bool in_upper_link = sos_is_greater(n_scalar, n_id, fi, voxel_id);
            if (in_upper_link) {
                upper_link_mask |= (1u << i);
                uint max_id = ascending[n_id];
                bool found = false;
                for (int j = 0; j < reachable_maxima_count; j++) {
                    if (reachable_maxima[j] == max_id) {
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    reachable_maxima[reachable_maxima_count++] = max_id;
                }
            }
        }
        
        if (reachable_maxima_count == 0) {
            type = MAXIMUM;
            atomicAdd(numMaxima, 1u);
        } else if (reachable_maxima_count > 1) {
            int num_components = count_link_components(upper_link_mask);
            if (num_components > 1) {
                type = SPLIT_SADDLE;
                atomicAdd(numSplitSaddles, 1u);
            }
        }
        
        // ===== Analyze DESCENDING manifold (minima + join saddles) =====
        // Only check if not already classified as maximum or split saddle
        if (type == REGULAR) {
            uint reachable_minima[NUM_NEIGHBORS];
            int  reachable_minima_count = 0;
            uint lower_link_mask = 0u;
            
            for (int i = 0; i < NUM_NEIGHBORS; i++) {
                uint n_id = neighbor_ids[i];
                if (n_id == 0xFFFFFFFFu) continue;
                float n_scalar = neighbor_scalars[i];
                bool in_lower_link = sos_is_greater(fi, voxel_id, n_scalar, n_id);
                if (in_lower_link) {
                    lower_link_mask |= (1u << i);
                    uint min_id = descending[n_id];
                    bool found = false;
                    for (int j = 0; j < reachable_minima_count; j++) {
                        if (reachable_minima[j] == min_id) {
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        reachable_minima[reachable_minima_count++] = min_id;
                    }
                }
            }
            
            if (reachable_minima_count == 0) {
                type = MINIMUM;
                atomicAdd(numMinima, 1u);
            } else if (reachable_minima_count > 1) {
                int num_components = count_link_components(lower_link_mask);
                if (num_components > 1) {
                    type = JOIN_SADDLE;
                    atomicAdd(numJoinSaddles, 1u);
                }
            }
        }
    }
    
    types[voxel_id] = type;

    barrier();
    if (gl_LocalInvocationIndex == 0) {
        atomicAdd(maximaCount,      numMaxima);
        atomicAdd(splitSaddleCount, numSplitSaddles);
        atomicAdd(minimaCount,      numMinima);
        atomicAdd(joinSaddleCount,  numJoinSaddles);
    }
}