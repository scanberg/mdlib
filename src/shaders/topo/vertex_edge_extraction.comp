#version 450

layout(local_size_x = 64) in;

// UBO data (shared across all shaders)
layout(std140, binding = 0) uniform UBO {
    mat4  index_to_world;
    uvec3 dims;
    float scalar_threshold;
};

// Input: critical point indices (ordered: maxima, split_saddles, minima, join_saddles)
layout(std430, binding = 1) readonly buffer CriticalPointIndices {
    uint cp_indices[];
};

// Input: type counts for indexing
layout(std430, binding = 2) readonly buffer TypeCounts {
    uint num_maxima;
    uint num_split_saddles;
    uint num_minima;
    uint num_join_saddles;
    uint num_vertices;
};

// Input: ascending/descending manifolds for edge extraction
layout(std430, binding = 3) readonly buffer AscendingManifold {
    uint ascending[];
};

layout(std430, binding = 4) readonly buffer DescendingManifold {
    uint descending[];
};

// Input: volume texture for sampling values
layout(binding = 0, r32f) uniform readonly image3D volumeTex;

// Output: vertex data (positions + values)
layout(std430, binding = 5) writeonly buffer Vertices {
    vec4 vertex_data[];  // xyz = position, w = value
};

// Output: edges (from, to pairs)
layout(std430, binding = 6) writeonly buffer Edges {
    uvec2 edges[];  // x = from vertex index, y = to vertex index
};

// Edge counter
layout(std430, binding = 7) buffer EdgeCounter {
    uint edge_count;
};

// Input: voxel_id -> vertex_index mapping (overwritten types buffer)
layout(std430, binding = 8) readonly buffer VoxelToVertexIndex {
    int voxel_to_vertex_idx[];
};

// Shared memory for workgroup-local operations
shared uint local_edge_count;
shared uint global_edge_offset;

#define MAX_LOCAL_EDGES 512
shared uvec2 local_edges[MAX_LOCAL_EDGES];

// Helper functions
ivec3 get_voxel_coords(uint id) {
    int x = int(id % dims.x);
    int y = int((id / dims.x) % dims.y);
    int z = int(id / (dims.x * dims.y));
    return ivec3(x, y, z);
}

vec3 voxel_to_world(ivec3 ijk) {
    vec4 world_pos = index_to_world * vec4(vec3(ijk), 1.0);
    return world_pos.xyz;
}

float get_scalar(ivec3 ijk) {
    return imageLoad(volumeTex, ijk).r;
}

// Get critical point type based on vertex index
uint get_type(uint vert_idx) {
    if (vert_idx < num_maxima) return 1; // MAXIMUM
    if (vert_idx < num_maxima + num_split_saddles) return 2; // SPLIT_SADDLE
    if (vert_idx < num_maxima + num_split_saddles + num_minima) return 3; // MINIMUM
    return 4; // JOIN_SADDLE
}

// Get vertex index for a given voxel ID using direct mapping
// Returns 0xFFFFFFFF if not found
uint get_vertex_index(uint voxel_id) {
    int idx = voxel_to_vertex_idx[voxel_id];
    return (idx >= 0) ? uint(idx) : 0xFFFFFFFFu;
}

void main() {
    uint vert_idx = gl_GlobalInvocationID.x;
    uint local_id = gl_LocalInvocationID.x;
    
    // Initialize shared memory
    if (local_id == 0) {
        local_edge_count = 0;
    }
    barrier();

    if (vert_idx < num_vertices) {
        // === Extract vertex data ===
        uint  voxel_id     = cp_indices[vert_idx];
        ivec3 voxel_coords = get_voxel_coords(voxel_id);
        vec3  world_pos    = voxel_to_world(voxel_coords);
        float value        = get_scalar(voxel_coords);
        
        vertex_data[vert_idx] = vec4(world_pos, value);
        
        // === Extract edges based on manifold connectivity ===
        uint type = get_type(vert_idx);
        
        // Store edges in local shared memory first
        uint target_voxel = 0xFFFFFFFF;

        // Explicit neighbor offsets for 26-connectivity
        const ivec3 neighbors[26] = ivec3[](
            ivec3(-1, -1, -1), ivec3(0, -1, -1), ivec3(1, -1, -1),
            ivec3(-1, 0, -1),  ivec3(0, 0, -1),  ivec3(1, 0, -1),
            ivec3(-1, 1, -1),  ivec3(0, 1, -1),  ivec3(1, 1, -1),
            
            ivec3(-1, -1, 0),  ivec3(0, -1, 0),  ivec3(1, -1, 0),
            ivec3(-1, 0, 0),                     ivec3(1, 0, 0),
            ivec3(-1, 1, 0),   ivec3(0, 1, 0),   ivec3(1, 1, 0),
            
            ivec3(-1, -1, 1),  ivec3(0, -1, 1),  ivec3(1, -1, 1),
            ivec3(-1, 0, 1),   ivec3(0, 0, 1),   ivec3(1, 0, 1),
            ivec3(-1, 1, 1),   ivec3(0, 1, 1),   ivec3(1, 1, 1)
        );
        
        if (type == 2) { // SPLIT_SADDLE
            // Iterate over 26-neighborhood
            uint unique_targets[8]; // max 8 unique CPs (adjacency theory)
            uint unique_count = 0;
            ivec3 center = get_voxel_coords(voxel_id);
            for (int n = 0; n < 26; ++n) {
                ivec3 nc = center + neighbors[n];
                if (any(lessThan(nc, ivec3(0))) || any(greaterThanEqual(nc, ivec3(dims)))) continue;
                uint nid = uint(nc.x) + uint(nc.y) * dims.x + uint(nc.z) * dims.x * dims.y;
                // Follow ascending manifold from neighbor to its CP
                uint cp_voxel = ascending[nid];
                if (cp_voxel == 0xFFFFFFFFu || cp_voxel == voxel_id) continue;
                // Map to vertex index
                uint cp_idx = get_vertex_index(cp_voxel);
                if (cp_idx == 0xFFFFFFFFu) continue;
                // Uniqueness check (linear scan, max 8)
                bool found = false;
                for (uint i = 0; i < unique_count; ++i) {
                    if (unique_targets[i] == cp_idx) { found = true; break; }
                }
                if (!found && unique_count < 8) {
                    unique_targets[unique_count++] = cp_idx;
                }
            }
            // Emit edges to all unique CPs
            for (uint i = 0; i < unique_count; ++i) {
                uint target_idx = unique_targets[i];
                uint local_idx = atomicAdd(local_edge_count, 1);
                if (local_idx < MAX_LOCAL_EDGES) {
                    local_edges[local_idx] = uvec2(vert_idx, target_idx);
                }
            }
        }
        else if (type == 4) { // JOIN_SADDLE
            // Iterate over 26-neighborhood
            uint unique_targets[8]; // max 8 unique CPs (adjacency theory)
            uint unique_count = 0;
            ivec3 center = get_voxel_coords(voxel_id);
            for (int n = 0; n < 26; ++n) {
                ivec3 nc = center + neighbors[n];
                if (any(lessThan(nc, ivec3(0))) || any(greaterThanEqual(nc, ivec3(dims)))) continue;
                uint nid = uint(nc.x) + uint(nc.y) * dims.x + uint(nc.z) * dims.x * dims.y;
                // Follow descending manifold from neighbor to its CP
                uint cp_voxel = descending[nid];
                if (cp_voxel == 0xFFFFFFFFu || cp_voxel == voxel_id) continue;
                // Map to vertex index
                uint cp_idx = get_vertex_index(cp_voxel);
                if (cp_idx == 0xFFFFFFFFu) continue;
                // Uniqueness check (linear scan, max 8)
                bool found = false;
                for (uint i = 0; i < unique_count; ++i) {
                    if (unique_targets[i] == cp_idx) { found = true; break; }
                }
                if (!found && unique_count < 8) {
                    unique_targets[unique_count++] = cp_idx;
                }
            }
            // Emit edges to all unique CPs
            for (uint i = 0; i < unique_count; ++i) {
                uint target_idx = unique_targets[i];
                uint local_idx = atomicAdd(local_edge_count, 1);
                if (local_idx < MAX_LOCAL_EDGES) {
                    local_edges[local_idx] = uvec2(vert_idx, target_idx);
                }
            }
        }
    }
    
    barrier();
    
    // One thread reserves space in global buffer and writes all local edges
    if (local_id == 0 && local_edge_count > 0) {
        uint write_count = min(local_edge_count, MAX_LOCAL_EDGES);
        global_edge_offset = atomicAdd(edge_count, write_count);
    }
    barrier();
    
    // Threads cooperatively write local edges to global memory
    uint write_count = min(local_edge_count, MAX_LOCAL_EDGES);
    for (uint i = local_id; i < write_count; i += 64) {
        edges[global_edge_offset + i] = local_edges[i];
    }
}
