#version 430 core

struct PGTO {
    float coeff;
    float alpha;
    uint ijkl;
};

struct CGTO {
    vec3 coord;
    uint pgto_off;
    uint pgto_len;
};

layout (binding = 0, std430) readonly restrict buffer CGTO_XYZR_BUFFER {
    vec4 cgto_xyzr[];
};
layout (binding = 1, std430) readonly restrict buffer CGTO_OFFSET_BUFFER {
    uint cgto_offset[];
};
layout (binding = 2, std430) readonly restrict buffer PGTO_COEFF_BUFFER {
    float pgto_coeff[];
};
layout (binding = 3, std430) readonly restrict buffer PGTO_ALPHA_BUFFER {
    float pgto_alpha[];
};
layout (binding = 4, std430) readonly restrict buffer PGTO_RADIUS_BUFFER {
    float pgto_radius[];
};
layout (binding = 5, std430) readonly restrict buffer PGTO_IJKL_BUFFER {
    uint pgto_ijkl[];
};

layout (binding = 6, std430) readonly restrict buffer D_BUFFER {
    float D_matrix[];
};

layout(std140, binding = 0) uniform UniformBlock {
    mat4 world_to_model;
    mat4 index_to_world;
    vec4 step;
    uint D_matrix_dim;
};

layout(binding = 0) writeonly restrict uniform image3D out_vol;

uvec4 unpack_ijkl(in uint ijkl) {
    return uvec4(
        (ijkl >>  0) & 0xFFu,
        (ijkl >>  8) & 0xFFu,
        (ijkl >> 16) & 0xFFu,
        (ijkl >> 24) & 0xFFu
    );
}

#define WG_X 8
#define WG_Y 8
#define WG_Z 8

#define WG_SIZE (WG_X * WG_Y * WG_Z)
#define TILE_SIZE 32
#define TILE_AREA (TILE_SIZE*TILE_SIZE)
#define MAX_SCREENED_CGTOS 2048
#define MAX_TILE_PGTOS (TILE_SIZE * 16)
#define INVALID_CGTO_IDX 0xFFFFFFFFu

shared uint  screened_cgtos[MAX_SCREENED_CGTOS];
shared uint  num_screened_cgtos;

shared float D_tile[TILE_SIZE][TILE_SIZE];
shared CGTO  cgtos_tile[TILE_SIZE];
shared PGTO  pgtos_tile[MAX_TILE_PGTOS];
shared uint  num_pgtos;

uint get_index(uint i, uint j, uint N) {
    uint row = min(i, j);
    uint col = max(i, j);
    uint row_offset = row * (2 * N - row + 1) / 2;
    return row_offset + (col - row);
}

void fill_D_tile(uint tile_i, uint tile_j) {
    const uint tid  = gl_LocalInvocationIndex;

    uint baseI = tile_i * TILE_SIZE;
    uint baseJ = tile_j * TILE_SIZE;

    for (uint index = tid; index < TILE_AREA; index += WG_SIZE) {
        uint row = index / TILE_SIZE;
        uint col = index % TILE_SIZE;

        uint idxI = baseI + row;
        uint gi = (idxI < MAX_SCREENED_CGTOS) ? screened_cgtos[idxI] : INVALID_CGTO_IDX;

        uint idxJ = baseJ + col;
        uint gj = (idxJ < MAX_SCREENED_CGTOS) ? screened_cgtos[idxJ] : INVALID_CGTO_IDX;

        float value = 0.0;
        if (gi != INVALID_CGTO_IDX && gj != INVALID_CGTO_IDX) {
            value = D_matrix[get_index(gi, gj, D_matrix_dim)];
        }
        D_tile[row][col] = value;
    }
}

void fill_cgtos_tile(uint tile_number, vec3 model_aabb_min, vec3 model_aabb_max) {
    const uint tid  = gl_LocalInvocationIndex;

    if (tid >= TILE_SIZE) return;

    uint global_cgto_idx = screened_cgtos[tile_number * TILE_SIZE + tid];

    vec3 cgto_center = vec3(0.0);
    uint cgto_pgto_off = 0u;
    uint cgto_pgto_len = 0u;

    if (global_cgto_idx != INVALID_CGTO_IDX) {
        uint src_beg = cgto_offset[global_cgto_idx];
        uint src_end = cgto_offset[global_cgto_idx + 1u];
        uint src_len = src_end - src_beg;

        uint dst = atomicAdd(num_pgtos, src_len);

        cgto_center = cgto_xyzr[global_cgto_idx].xyz;
        cgto_pgto_off = dst;
        
        vec3 model_xyz = vec3(world_to_model * vec4(cgto_center, 1.0));
        vec3   d = clamp(model_xyz, model_aabb_min, model_aabb_max) - model_xyz;
        float d2 = dot(d, d);

        for (uint k = 0; k < src_len; ++k) {
            float r = pgto_radius[src_beg + k];
            if (d2 < r * r) {
                PGTO g;
                g.coeff = pgto_coeff[src_beg + k];
                g.alpha = pgto_alpha[src_beg + k];
                g.ijkl  = pgto_ijkl[src_beg + k];
                pgtos_tile[cgto_pgto_off + cgto_pgto_len] = g;
                cgto_pgto_len++;
            }
        }
    }

    cgtos_tile[tid].coord    = cgto_center;
    cgtos_tile[tid].pgto_off = cgto_pgto_off;
    cgtos_tile[tid].pgto_len = cgto_pgto_len;
}

// Evaluate φ and ∇φ together as vec4(φ, ∇φ)
void eval_phis(out vec4 out_phi[TILE_SIZE], vec3 coord) {
    for (uint i = 0; i < TILE_SIZE; ++i) out_phi[i] = vec4(0.0);

    for (uint i = 0; i < TILE_SIZE; ++i) {
        uint pgto_off = cgtos_tile[i].pgto_off;
        uint pgto_len = cgtos_tile[i].pgto_len;

        vec3 center = cgtos_tile[i].coord;
        vec3 d   = coord - center;
        float r2 = dot(d, d);

        float dx2 = d.x * d.x;
        float dy2 = d.y * d.y;
        float dz2 = d.z * d.z;

        vec4 phi_grad = vec4(0.0); // (∇φ_x, ∇φ_y, ∇φ_z, φ)

        for (uint j = pgto_off; j < pgto_off + pgto_len; ++j) {
            PGTO pgto = pgtos_tile[j];
            uvec4 ijkl = unpack_ijkl(pgto.ijkl);
            
            // Compute powers and their derivatives
            float fx, dfx;
            if (ijkl.x == 0u) {
                fx = 1.0; dfx = 0.0;
            } else if (ijkl.x == 1u) {
                fx = d.x; dfx = 1.0;
            } else if (ijkl.x == 2u) {
                fx = dx2; dfx = 2.0 * d.x;
            } else if (ijkl.x == 3u) {
                fx = dx2 * d.x; dfx = 3.0 * dx2;
            } else {
                fx = dx2 * dx2; dfx = 4.0 * dx2 * d.x;
            }
            
            float fy, dfy;
            if (ijkl.y == 0u) {
                fy = 1.0; dfy = 0.0;
            } else if (ijkl.y == 1u) {
                fy = d.y; dfy = 1.0;
            } else if (ijkl.y == 2u) {
                fy = dy2; dfy = 2.0 * d.y;
            } else if (ijkl.y == 3u) {
                fy = dy2 * d.y; dfy = 3.0 * dy2;
            } else {
                fy = dy2 * dy2; dfy = 4.0 * dy2 * d.y;
            }
            
            float fz, dfz;
            if (ijkl.z == 0u) {
                fz = 1.0; dfz = 0.0;
            } else if (ijkl.z == 1u) {
                fz = d.z; dfz = 1.0;
            } else if (ijkl.z == 2u) {
                fz = dz2; dfz = 2.0 * d.z;
            } else if (ijkl.z == 3u) {
                fz = dz2 * d.z; dfz = 3.0 * dz2;
            } else {
                fz = dz2 * dz2; dfz = 4.0 * dz2 * d.z;
            }

            float gauss = exp(-pgto.alpha * r2);
            float radial_factor = -2.0 * pgto.alpha * gauss;
            
            float angular = fx * fy * fz;
            float coeff_gauss = pgto.coeff * gauss;
            
            // ∇φ = coeff * [∇(angular) * gauss + angular * ∇(gauss)]
            // ∇(angular) = (∂fx/∂x * fy * fz, fx * ∂fy/∂y * fz, fx * fy * ∂fz/∂z)
            // ∇(gauss) = -2α * r * gauss = -2α * (dx, dy, dz) * gauss
            phi_grad.x += coeff_gauss * (dfx * fy * fz + angular * radial_factor * d.x);
            phi_grad.y += coeff_gauss * (fx * dfy * fz + angular * radial_factor * d.y);
            phi_grad.z += coeff_gauss * (fx * fy * dfz + angular * radial_factor * d.z);

            // φ = coeff * angular * gauss
            phi_grad.w += pgto.coeff * angular * gauss;
        }
        
        out_phi[i] = phi_grad;
    }
}

// Compute both ρ and ∇ρ from diagonal tile: vec4(∇ρ, ρ)
vec4 symmetric_contraction(vec4 phi[TILE_SIZE], float D[TILE_SIZE][TILE_SIZE]) {
    vec4 result = vec4(0.0);
    for (uint i = 0; i < TILE_SIZE; ++i) {
        vec4 phi_i = phi[i];
        
        // Diagonal: D[i][i] * φ_i² → ∇(D * φ_i²) = 2 * D * φ_i * ∇φ_i
        float D_ii = D[i][i];
        result.xyz += 2.0 * D_ii * phi_i.w * phi_i.xyz;
        result.w += D_ii * phi_i.w * phi_i.w;
        
        for (uint j = i + 1; j < TILE_SIZE; ++j) {
            vec4 phi_j = phi[j];
            float D_ij = D[i][j];
            
            // Off-diagonal: 2 * D[i][j] * φ_i * φ_j
            // ∇(2 * D * φ_i * φ_j) = 2 * D * (φ_i * ∇φ_j + φ_j * ∇φ_i)
            result.xyz += 2.0 * D_ij * (phi_i.w * phi_j.xyz + phi_j.w * phi_i.xyz);
            result.w += 2.0 * D_ij * phi_i.w * phi_j.w;
        }
    }
    return result;
}

// Compute both ρ and ∇ρ from off-diagonal tile: vec4(∇ρ, ρ)
vec4 contraction(vec4 phi_mu[TILE_SIZE], vec4 phi_nu[TILE_SIZE], float D[TILE_SIZE][TILE_SIZE]) {
    vec4 result = vec4(0.0);
    for (uint i = 0; i < TILE_SIZE; ++i) {
        vec4 phi_i = phi_mu[i];
        for (uint j = 0; j < TILE_SIZE; ++j) {
            vec4 phi_j = phi_nu[j];
            float D_ij = D[i][j];
            
            // 2 * D[i][j] * φ_μ[i] * φ_ν[j]
            // ∇(2 * D * φ_μ * φ_ν) = 2 * D * (φ_μ * ∇φ_ν + φ_ν * ∇φ_μ)
            result.xyz += 2.0 * D_ij * (phi_i.w * phi_j.xyz + phi_j.w * phi_i.xyz);
            result.w += 2.0 * D_ij * phi_i.w * phi_j.w;
        }
    }
    return result;
}

layout (local_size_x = WG_X, local_size_y = WG_Y, local_size_z = WG_Z) in;
void main() {
    uint tid = gl_LocalInvocationIndex;
    if (tid == 0) {
        num_screened_cgtos = 0;
    }
    barrier();

    vec3 model_aabb_min = vec3( gl_WorkGroupID.xyz                 * gl_WorkGroupSize.xyz) * step.xyz;
    vec3 model_aabb_max = vec3((gl_WorkGroupID.xyz + uvec3(1,1,1)) * gl_WorkGroupSize.xyz) * step.xyz;
    
    // Stage 1: Screening
    {
        for (uint i = tid; i < D_matrix_dim; i += WG_SIZE) {
            vec4 cgto = cgto_xyzr[i];
            if (cgto.w == 0.0) continue;

            vec3 model_xyz = vec3(world_to_model * vec4(cgto.xyz, 1.0));
            float r2       = cgto.w * cgto.w;

            vec3   d = clamp(model_xyz, model_aabb_min, model_aabb_max) - model_xyz;
            float d2 = dot(d, d);

            if (d2 < r2) {
                uint idx = atomicAdd(num_screened_cgtos, 1u);
                if (idx < MAX_SCREENED_CGTOS) {
                    screened_cgtos[idx] = i;
                }
            }
        }

        barrier();

        if (tid == 0) {
            if (num_screened_cgtos > MAX_SCREENED_CGTOS) {
                num_screened_cgtos = MAX_SCREENED_CGTOS;
            }
        }
        barrier();

        for (uint i = tid; i < MAX_SCREENED_CGTOS; i += WG_SIZE) {
            if (i >= num_screened_cgtos) {
                screened_cgtos[i] = INVALID_CGTO_IDX;
            }
        }
        barrier();
    }

    vec4 phi_tile_mu[TILE_SIZE]; // vec4(φ_μ, ∇φ_μ) in registers
    vec4 phi_tile_nu[TILE_SIZE]; // vec4(φ_ν, ∇φ_ν) in registers
    vec3 coord = (index_to_world * vec4(gl_GlobalInvocationID.xyz, 1.0)).xyz;
    vec4 rho_grad = vec4(0.0); // (ρ, ∇ρ_x, ∇ρ_y, ∇ρ_z)

    if (num_screened_cgtos == 0u) {
        if (all(lessThan(gl_GlobalInvocationID.xyz, imageSize(out_vol)))) {
            imageStore(out_vol, ivec3(gl_GlobalInvocationID.xyz), vec4(0.0));
        }
        return;
    }

    uint num_tiles = (num_screened_cgtos + TILE_SIZE - 1) / TILE_SIZE;

    for (uint tile_i = 0; tile_i < num_tiles; ++tile_i) {
        // DIAGONAL TILE
        if (tid == 0) {
            num_pgtos = 0;
        }
        barrier();

        fill_D_tile(tile_i, tile_i);
        fill_cgtos_tile(tile_i, model_aabb_min, model_aabb_max);

        barrier();

        eval_phis(phi_tile_mu, coord);

        rho_grad += symmetric_contraction(phi_tile_mu, D_tile);

        for (uint tile_j = tile_i + 1; tile_j < num_tiles; ++tile_j) {
            // OFF DIAGONAL TILE
            if (tid == 0) {
                num_pgtos = 0;
            }

            barrier();

            fill_D_tile(tile_i, tile_j);
            fill_cgtos_tile(tile_j, model_aabb_min, model_aabb_max);

            barrier();

            eval_phis(phi_tile_nu, coord);

            rho_grad += contraction(phi_tile_mu, phi_tile_nu, D_tile);
        }
    }
    
    // Write result: vec4(∇ρ_x, ∇ρ_y, ∇ρ_z, ρ)
    if (all(lessThan(gl_GlobalInvocationID.xyz, imageSize(out_vol)))) {
        imageStore(out_vol, ivec3(gl_GlobalInvocationID.xyz), rho_grad);
    }
}