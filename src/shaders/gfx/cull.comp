#version 460

#include "common.h"

layout (binding = 0, std140) uniform UboBuffer {
    UniformData ubo;
};

layout (binding = POSITION_BINDING, std430) readonly buffer PositionBuffer {
	Position positions[];
};

layout (binding = RADIUS_BINDING, std430) readonly buffer RadiusBuffer {
	float radius[];
};

layout (binding = GROUP_BINDING, std430) readonly buffer GroupBuffer {
	Group groups[];
};

layout (binding = TRANSFORM_BINDING, std430) readonly buffer TransformBuffer {
	mat4 transforms[];
};

layout (binding = DRAW_OP_BINDING, std430) readonly buffer InputDrawOperations {
	DrawOp ops[];
};

layout (binding = DRAW_INDIRECT_BINDING, std430) buffer DrawIndirectBuffer {
	DrawIndirect indirect;
};

layout (binding = DRAW_SPHERE_INDEX_BINDING, std430) buffer DrawSphereIndices {
	uint sphere_indices[];
};

layout (binding = DEBUG_BINDING, std430) buffer DebugBuffer {
	DebugData debug;
};

layout(binding = 0) uniform sampler2D in_depth_pyramid_tex;

layout (local_size_x = CULL_GROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

shared uint total_write_count = 0;
shared uint total_write_offset = 0;

// 2D Polyhedral Bounds of a Clipped, Perspective-Projected 3D Sphere. Michael Mara, Morgan McGuire. 2013
void project_sphere(vec4 S, float P00, float P11, out vec4 aabb)
{
	vec2 cx = -S.xz;
	vec2 vx = vec2(sqrt(dot(cx, cx) - S.w * S.w), S.w);
	vec2 minx = mat2(vx.x, vx.y, -vx.y, vx.x) * cx;
	vec2 maxx = mat2(vx.x, -vx.y, vx.y, vx.x) * cx;

	vec2 cy = -S.yz;
	vec2 vy = vec2(sqrt(dot(cy, cy) - S.w * S.w), S.w);
	vec2 miny = mat2(vy.x, vy.y, -vy.y, vy.x) * cy;
	vec2 maxy = mat2(vy.x, -vy.y, vy.y, vy.x) * cy;

	aabb = vec4(minx.x / minx.y * P00, miny.x / miny.y * P11, maxx.x / maxx.y * P00, maxy.x / maxy.y * P11);
	aabb = aabb.xwzy * vec4(0.5f, 0.5f, 0.5f, 0.5f) + vec4(0.5f); // clip space -> uv space
}

void project_aabb(vec3 aabb_min, vec3 aabb_max, mat4 MVP, out vec3 out_aabb_min, out vec3 out_aabb_max) {
	vec3 min_xyz = vec3(POS_INF,POS_INF,POS_INF);
	vec3 max_xyz = vec3(NEG_INF,NEG_INF,NEG_INF);
	vec3 o = aabb_min;
	vec3 d = aabb_max - aabb_min;
	for (int i = 0; i < 8; ++i) {
		vec3 v = o + d * vec3(float((i & 4) >> 2), float((i & 2) >> 1), float(i & 1));
		vec4 p = MVP * vec4(v, 1);
		p.xyz = p.xyz / p.w;
		min_xyz = min(min_xyz, p.xyz);
		max_xyz = max(max_xyz, p.xyz);
	}
	// [-1,1] to [0,1]
	out_aabb_min = min_xyz * 0.5 + 0.5;
	out_aabb_max = max_xyz * 0.5 + 0.5;
}

void main() {
	uint draw_idx = gl_WorkGroupID.x;
	uint group_idx = gl_LocalInvocationID.x;

	if (group_idx == 0) {
		total_write_count = 0;
		total_write_offset = 0;
	}

	uint atom_base_offset = groups[ops[draw_idx].group_offset + 0].atom_offset;

	if (group_idx < ops[draw_idx].group_count) {
		uint group_write_offset = 0;
		uint group_atom_offset = groups[ops[draw_idx].group_offset + group_idx].atom_offset;
		uint group_atom_count  = groups[ops[draw_idx].group_offset + group_idx].atom_count;

		mat4 model_mat = transforms[ops[draw_idx].transform_idx];

		// Compute AABB
		vec3 aabb_min = vec3(POS_INF,POS_INF,POS_INF);
		vec3 aabb_max = vec3(NEG_INF,NEG_INF,NEG_INF);
		for (uint j = group_atom_offset; j < group_atom_offset + group_atom_count; ++j) {
			uint idx = ops[draw_idx].atom_offset + j;
			vec3 pos = vec3(positions[idx].x, positions[idx].y, positions[idx].z);
			float rad = radius[idx];
			aabb_min = min(aabb_min, pos - rad);
			aabb_max = max(aabb_max, pos + rad);
		}
		vec3 aabb_uv_min;
		vec3 aabb_uv_max;
		project_aabb(aabb_min, aabb_max, ubo.prev_world_to_clip * model_mat, aabb_uv_min, aabb_uv_max);

		bool visible = true;

		// Frustum Culling
		if (ubo.frustum_culling == 1) {
			visible = visible &&
				(0 < aabb_uv_max.x && aabb_uv_min.x < 1) &&
				(0 < aabb_uv_max.y && aabb_uv_min.y < 1) &&
				(0 < aabb_uv_max.z && aabb_uv_min.z < 1);
		}

		// HiZ Culling
		if (visible && ubo.depth_culling == 1) {
			float width  = (aabb_uv_max.x - aabb_uv_min.x) * float(ubo.depth_pyramid_width);
			float height = (aabb_uv_max.y - aabb_uv_min.y) * float(ubo.depth_pyramid_height);
			float level  = floor(log2(max(width, height)));

			// Sampler is set up to do max reduction, so this computes the maximum depth of a 2x2 texel quad
			float depth_ref = textureLod(in_depth_pyramid_tex, (aabb_uv_min.xy + aabb_uv_max.xy) * 0.5, level).x;
			float depth_min = aabb_uv_min.z;

			/*
			if (group_idx == 0) {
				debug.aabb_depth = depth_min;
				debug.read_depth = depth_ref;
				debug.aabb_min[0] = aabb_uv_min.x;
				debug.aabb_min[1] = aabb_uv_min.y;
				debug.aabb_max[0] = aabb_uv_max.x;
				debug.aabb_max[1] = aabb_uv_max.y;
				debug.aabb_width = width;
				debug.aabb_height = height;
				debug.lod = level;
			}
			*/

			visible = visible && (depth_min <= depth_ref);
		}

		if (visible) {
			group_write_offset = atomicAdd(total_write_count, group_atom_count);
		}


		// SYNC
		barrier();

		if (group_idx == 0) {
			atomicAdd(indirect.draw_sphere_cmd_count, 1);
			total_write_offset = atomicAdd(indirect.sphere_idx_count, total_write_count);
		}

		// SYNC
		barrier();

		//atomicAdd(debug.total_groups_processed, 1);
		if (visible) {
			//atomicAdd(debug.total_groups_drawn, 1);

			for (uint j = 0; j < group_atom_count; ++j) {
				// Write relative offsets (To the draw command, this allows for 16 bit indices)
				sphere_indices[total_write_offset + group_write_offset + j] = group_atom_offset + j - atom_base_offset;
			}
		}

		if (group_idx == 0) {
			indirect.draw_sphere_cmd[draw_idx].cmd.count = total_write_count;
			indirect.draw_sphere_cmd[draw_idx].cmd.instance_count = 1;
			indirect.draw_sphere_cmd[draw_idx].cmd.first_index = total_write_offset;
			indirect.draw_sphere_cmd[draw_idx].cmd.base_vertex = atom_base_offset;
			indirect.draw_sphere_cmd[draw_idx].cmd.base_instance = ops[draw_idx].atom_offset;

			indirect.draw_sphere_cmd[draw_idx].transform_idx = ops[draw_idx].transform_idx;
			indirect.draw_sphere_cmd[draw_idx].color_offset  = ops[draw_idx].color_offset;
			indirect.draw_sphere_cmd[draw_idx].radius_scale  = ops[draw_idx].rep_args[0];
		}
	}
}