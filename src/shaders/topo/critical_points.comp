// critical_points.comp
#version 450

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

// UBO data (shared across all shaders)
layout(std140, binding = 0) uniform UBO {
    mat4 index_to_world;
    uvec3 dims;
    float scalar_threshold;
};

// Input volume texture
layout(binding = 0, r32f) uniform readonly image3D volumeTex;

layout(std430, binding = 1) readonly buffer AscendingManifold {
    uint ascending[];
};

layout(std430, binding = 2) readonly buffer DescendingManifold {
    uint descending[];
};

// Output buffers
layout(std430, binding = 3) writeonly buffer CriticalPointTypes {
    int types[];
};

layout (std430, binding = 4) buffer CriticalPointCounts {
    uint maximaCount;
    uint splitSaddleCount;  // saddles in ascending manifold
    uint minimaCount;
    uint joinSaddleCount;   // saddles in descending manifold
    uint edgeCount;         // total number of unique edges
};

#define REGULAR 0
#define MAXIMUM 1
#define SPLIT_SADDLE 2
#define MINIMUM 3
#define JOIN_SADDLE 4

#define NUM_NEIGHBORS 26

bool is_valid_voxel(ivec3 ijk) {
    return all(greaterThanEqual(ijk, ivec3(0))) &&
           all(lessThan(ijk, ivec3(dims)));
}

// Helper functions
float get_scalar(ivec3 ijk) {
    if (!is_valid_voxel(ijk)) {
        return 0; // Guard against out-of-bounds
    }
    return imageLoad(volumeTex, ijk).r;
}

uint get_voxel_id(ivec3 ijk) {
    if (!is_valid_voxel(ijk)) {
        return 0xFFFFFFFFu;
    }
    return uint(ijk.x + ijk.y * dims.x + ijk.z * dims.x * dims.y);
}

bool sos_is_greater(float value_a, uint id_a, float value_b, uint id_b) {
    return value_a > value_b || (value_a == value_b && id_a > id_b);
}

// Precomputed adjacency masks for 26 neighbors (bit i set if neighbor i is adjacent)
const uint adjacencyMasks[26] = {
    0x0000161A,
    0x00003E3D,
    0x00002C32,
    0x0000D6D3,
    0x0001FFEF,
    0x0001AD96,
    0x0000D098,
    0x0001F178,
    0x0001A0B0,
    0x0036141B,
    0x007E3A3F,
    0x006C2436,
    0x01B6C6DB,
    0x036D8DB6,
    0x01B090D8,
    0x03F171F8,
    0x0360A1B0,
    0x00341600,
    0x007A3E00,
    0x00642C00,
    0x01A6D600,
    0x03DFFE00,
    0x032DAC00,
    0x0130D000,
    0x02F1F000,
    0x0161A000,
};

uint create_upper_link_mask(uint voxel_id, float fi, uint neighbor_ids[NUM_NEIGHBORS], float neighbor_scalars[NUM_NEIGHBORS]) {
    uint link_mask = 0u;
    for (int i = 0; i < NUM_NEIGHBORS; i++) {
        uint n_id = neighbor_ids[i];
        if (n_id == 0xFFFFFFFFu) continue;

        float n_scalar = neighbor_scalars[i];
        bool in_link = sos_is_greater(n_scalar, n_id, fi, voxel_id);
        link_mask |= in_link ? (1u << i) : 0u;
    }
    return link_mask;
}

uint create_lower_link_mask(uint voxel_id, float fi, uint neighbor_ids[NUM_NEIGHBORS], float neighbor_scalars[NUM_NEIGHBORS]) {
    uint link_mask = 0u;
    for (int i = 0; i < NUM_NEIGHBORS; i++) {
        uint n_id = neighbor_ids[i];
        if (n_id == 0xFFFFFFFFu) continue;

        float n_scalar = neighbor_scalars[i];
        bool in_link = sos_is_greater(fi, voxel_id, n_scalar, n_id);
        link_mask |= in_link ? (1u << i) : 0u;
    }
    return link_mask;
}

// Count link components using bitmask and static adjacency
int count_link_components(uint link_mask) {
    if (link_mask == 0u) return 0;

    uint visited = 0u;
    int num_components = 0;
    // Count unvisited components
    for (int start = 0; start < NUM_NEIGHBORS; ++start) {
        uint bit = 1u << start;
        if ((link_mask & bit) == 0u) continue;
        if ((visited & bit) != 0u) continue;
        num_components++;

        // Bitwise flood-fill
        uint component = bit;
        uint prev = 0u;
        while (component != prev) {
            prev = component;
            for (int nb = 0; nb < NUM_NEIGHBORS; ++nb) {
                if ((component & (1u << nb)) != 0u) {
                    component |= adjacencyMasks[nb] & link_mask;
                }
            }
        }
        visited |= component;
    }

    return num_components;
}


// Shared memory for workgroup-local compaction
shared uint numMaxima;
shared uint numSplitSaddles;
shared uint numMinima;
shared uint numJoinSaddles;
shared uint numEdges;

// Shared memory for scalar values and voxel IDs in a 10x10x10 region (8x8x8 block + 1 padding in each direction)
shared float sharedScalars[10][10][10];
shared uint sharedIds[10][10][10];

void main() {
    // Compute global voxel index from 3D thread indices
    uvec3 gid = gl_GlobalInvocationID.xyz;
    if (any(greaterThanEqual(gid, dims))) {
        return;
    }
    uint voxelId = gid.x + gid.y * dims.x + gid.z * dims.x * dims.y;

    // Initialize shared memory for counters
    if (gl_LocalInvocationIndex == 0) {
        numMaxima = 0u;
        numSplitSaddles = 0u;
        numMinima = 0u;
        numJoinSaddles = 0u;
        numEdges = 0u;
    }

    // Compute local indices in shared memory (with +1 padding)
    ivec3 localIdx = ivec3(gl_LocalInvocationID.x + 1, gl_LocalInvocationID.y + 1, gl_LocalInvocationID.z + 1);
    ivec3 globalIdx = ivec3(gid);

    // Load scalar values and voxel IDs for the local block and its padding
    // Each thread loads its own value
    sharedScalars[localIdx.x][localIdx.y][localIdx.z] = get_scalar(globalIdx);
    sharedIds[localIdx.x][localIdx.y][localIdx.z] = voxelId;

    // Load padding (threads at the boundary load extra values)
    // X boundaries
    if (gl_LocalInvocationID.x == 0) {
        sharedScalars[0][localIdx.y][localIdx.z] = get_scalar(globalIdx + ivec3(-1, 0, 0));
        sharedIds[0][localIdx.y][localIdx.z] = get_voxel_id(globalIdx + ivec3(-1, 0, 0));
    }
    if (gl_LocalInvocationID.x == 7) {
        sharedScalars[9][localIdx.y][localIdx.z] = get_scalar(globalIdx + ivec3(1, 0, 0));
        sharedIds[9][localIdx.y][localIdx.z] = get_voxel_id(globalIdx + ivec3(1, 0, 0));
    }
    // Y boundaries
    if (gl_LocalInvocationID.y == 0) {
        sharedScalars[localIdx.x][0][localIdx.z] = get_scalar(globalIdx + ivec3(0, -1, 0));
        sharedIds[localIdx.x][0][localIdx.z] = get_voxel_id(globalIdx + ivec3(0, -1, 0));
    }
    if (gl_LocalInvocationID.y == 7) {
        sharedScalars[localIdx.x][9][localIdx.z] = get_scalar(globalIdx + ivec3(0, 1, 0));
        sharedIds[localIdx.x][9][localIdx.z] = get_voxel_id(globalIdx + ivec3(0, 1, 0));
    }
    // Z boundaries
    if (gl_LocalInvocationID.z == 0) {
        sharedScalars[localIdx.x][localIdx.y][0] = get_scalar(globalIdx + ivec3(0, 0, -1));
        sharedIds[localIdx.x][localIdx.y][0] = get_voxel_id(globalIdx + ivec3(0, 0, -1));
    }
    if (gl_LocalInvocationID.z == 7) {
        sharedScalars[localIdx.x][localIdx.y][9] = get_scalar(globalIdx + ivec3(0, 0, 1));
        sharedIds[localIdx.x][localIdx.y][9] = get_voxel_id(globalIdx + ivec3(0, 0, 1));
    }

    barrier();

    float fi = sharedScalars[localIdx.x][localIdx.y][localIdx.z];
    int type = REGULAR;

    if (scalar_threshold < fi) {
        // Get all neighbors using shared memory
        uint  neighbor_ids[NUM_NEIGHBORS];
        float neighbor_scalars[NUM_NEIGHBORS];
        int neighbor_count = 0;
        for (int dz = -1; dz <= 1; dz++) {
            for (int dy = -1; dy <= 1; dy++) {
                for (int dx = -1; dx <= 1; dx++) {
                    if (dx == 0 && dy == 0 && dz == 0) continue;
                    int nx = localIdx.x + dx;
                    int ny = localIdx.y + dy;
                    int nz = localIdx.z + dz;
                    neighbor_ids[neighbor_count] = sharedIds[nx][ny][nz];
                    neighbor_scalars[neighbor_count] = sharedScalars[nx][ny][nz];
                    neighbor_count++;
                }
            }
        }
        
        // ===== Analyze ASCENDING manifold (maxima + split saddles) =====
        uint reachable_maxima[NUM_NEIGHBORS];
        int  reachable_maxima_count = 0;
        
        for (int i = 0; i < neighbor_count; i++) {
            uint n_id = neighbor_ids[i];
            float n_scalar = neighbor_scalars[i];
            bool in_upper_link = sos_is_greater(n_scalar, n_id, fi, voxel_id);
            if (in_upper_link) {
                uint max_id = ascending[n_id];
                bool found = false;
                for (int j = 0; j < reachable_maxima_count; j++) {
                    if (reachable_maxima[j] == max_id) {
                        found = true;
                        break;
                    }
                }
                if (!found && reachable_maxima_count < NUM_NEIGHBORS) {
                    reachable_maxima[reachable_maxima_count++] = max_id;
                    atomicAdd(numEdges, 1u); // Count unique edge
                }
            }
        }
        
        if (reachable_maxima_count == 0) {
            type = MAXIMUM;
            atomicAdd(numMaxima, 1u);
        } else if (reachable_maxima_count > 1) {
            uint link_mask = create_upper_link_mask(voxel_id, fi, neighbor_ids, neighbor_scalars);
            if (count_link_components(link_mask) > 1) {
                type = SPLIT_SADDLE;
                atomicAdd(numSplitSaddles, 1u);
            }
        }
        
        // ===== Analyze DESCENDING manifold (minima + join saddles) =====
        // Only check if not already classified as maximum or split saddle
        if (type == REGULAR) {
            uint reachable_minima[NUM_NEIGHBORS];
            int  reachable_minima_count = 0;
            
            for (int i = 0; i < neighbor_count; i++) {
                uint n_id = neighbor_ids[i];
                float n_scalar = neighbor_scalars[i];
                bool in_lower_link = sos_is_greater(fi, voxel_id, n_scalar, n_id);
                if (in_lower_link) {
                    uint min_id = descending[n_id];
                    bool found = false;
                    for (int j = 0; j < reachable_minima_count; j++) {
                        if (reachable_minima[j] == min_id) {
                            found = true;
                            break;
                        }
                    }
                    if (!found && reachable_minima_count < NUM_NEIGHBORS) {
                        reachable_minima[reachable_minima_count++] = min_id;
                        atomicAdd(numEdges, 1u); // Count unique edge
                    }
                }
            }
            
            if (reachable_minima_count == 0) {
                type = MINIMUM;
                atomicAdd(numMinima, 1u);
            } else if (reachable_minima_count > 1) {
                uint link_mask = create_lower_link_mask(voxel_id, fi, neighbor_ids, neighbor_scalars);
                if (count_link_components(link_mask) > 1) {
                    type = JOIN_SADDLE;
                    atomicAdd(numJoinSaddles, 1u);
                }
            }
        }
    }
    
    types[voxelId] = type;

    barrier();
    if (gl_LocalInvocationIndex == 0) {
        atomicAdd(maximaCount,      numMaxima);
        atomicAdd(splitSaddleCount, numSplitSaddles);
        atomicAdd(minimaCount,      numMinima);
        atomicAdd(joinSaddleCount,  numJoinSaddles);
        atomicAdd(edgeCount,        numEdges);
    }
}