#version 460

#include "common.h"
#include "culling.glsl"

layout (binding = 0, std140) uniform UboBuffer {
    UniformData ubo;
};

layout (binding = TRANSFORM_BINDING, std430) readonly buffer TransformBuffer {
	mat4 in_transforms[];
};

layout (binding = CLUSTER_RANGE_BINDING, std430) readonly buffer ClusterRangeBuffer {
	uint in_cluster_ranges[];
};

layout (binding = CLUSTER_BOUNDS_BINDING, std430) readonly buffer ClusterBoundsBuffer {
	ClusterBounds in_cluster_bounds[];
};

layout (binding = INSTANCE_DATA_BINDING, std430) readonly buffer InInstanceData {
	InstanceData in_inst[];
};

layout (binding = INSTANCE_VIS_IDX_BINDING, std430) readonly buffer InstanceIdxBuffer {
	uint in_inst_idx[];
};

layout (binding = CLUSTER_INST_DATA_BINDING, std430) writeonly buffer ClusterInstanceBuffer {
	ClusterInstance out_clust_inst[];
};

layout (binding = CLUSTER_INST_VIS_IDX_BINDING, std430) writeonly buffer OutVisClusterIdxBuffer {
	uint out_clust_vis_idx[];
};

layout (binding = CLUSTER_INST_OCC_IDX_BINDING, std430) writeonly buffer OutOccClusterIdxBuffer {
	uint out_clust_occ_idx[];
};

layout (binding = CLUSTER_INST_RAST_IDX_BINDING, std430) writeonly buffer OutRastClusterIdxBuffer {
	uint out_clust_rast_idx[];
};

layout (binding = DRAW_INDIRECT_PARAM_BINDING, std430) buffer ParamBuffer {
	DrawParameters param;
};

layout (binding = DEBUG_BINDING, std430) buffer DebugBuffer {
	DebugData debug;
};

layout(binding = 0) uniform sampler2D in_depth_pyramid_tex;

layout (local_size_x = CLUSTER_CULL_GROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

shared InstanceData s_inst;
shared uint s_inst_idx;
shared mat4 M;

void main() {
	//  Instance Specific Data
	if (gl_LocalInvocationID.x == 0) {
		s_inst_idx = in_inst_idx[gl_WorkGroupID.x];
		s_inst = in_inst[s_inst_idx];
		M = in_transforms[s_inst.transform_idx];
	}
	barrier();

	uint cluster_offset = s_inst.cluster_offset;
	uint cluster_count  = s_inst.cluster_count;
	uint transform_idx  = s_inst.transform_idx;
	mat4 curr_MVP = ubo.world_to_clip * M;
	mat4 prev_MVP = ubo.prev_world_to_clip * M;

	for (uint i = gl_LocalInvocationID.x; i < cluster_count; i += gl_WorkGroupSize.x) {
		uint cluster_idx = cluster_offset + i;
		uint range = in_cluster_ranges[cluster_idx];
		uint cluster_offset = range >> 8;
		uint cluster_size   = range & 0xFF;

		ClusterBounds bounds = in_cluster_bounds[cluster_idx];
		vec3 aabb_min = bounds.cluster_min.xyz - bounds.cluster_max.w;
		vec3 aabb_max = bounds.cluster_max.xyz + bounds.cluster_max.w;

		if (ubo.frustum_culling == 1 && ubo.late == 0) {
			vec3 uv_aabb_min, uv_aabb_max;
			project_aabb(aabb_min, aabb_max, curr_MVP, uv_aabb_min, uv_aabb_max);
			if (!cull_frustum(uv_aabb_min, uv_aabb_max)) {
				continue;
			}
		}

		vec3 uv_aabb_min, uv_aabb_max;
		project_aabb(aabb_min, aabb_max, ubo.late == 0 ? prev_MVP : curr_MVP, uv_aabb_min, uv_aabb_max);
		vec2 cluster_ext = (uv_aabb_max.xy - uv_aabb_min.xy) * vec2(ubo.depth_pyramid_width, ubo.depth_pyramid_height);
		float max_ext = max(cluster_ext.x, cluster_ext.y);

		bool rasterize = max_ext < CLUSTER_RASTER_LIMIT_PIXEL_EXTENT;
		bool visible = true;

		if (ubo.depth_culling == 1) {
			visible = visible && cull_hiz(uv_aabb_min, uv_aabb_max, in_depth_pyramid_tex, ubo.depth_pyramid_width, ubo.depth_pyramid_height);
		}

		ClusterInstance clust_inst;
		clust_inst.cluster_range = range;
		clust_inst.cluster_idx = cluster_idx;
		clust_inst.transform_idx = transform_idx;
		clust_inst.rep_scale = 1.0f;

		// @TODO: Subgroup to reduce strain on L2
		uint clust_inst_idx;
		if (ubo.late == 0 || visible) {
			// Write cluster instance data
			clust_inst_idx = atomicAdd(param.cluster_inst_count, 1);
			out_clust_inst[clust_inst_idx] = clust_inst;
		}

		if (visible) {
			if (!rasterize) {
				// Write cluster instance index in visible cluster list
				uint idx = atomicAdd(param.cluster_vis_count, 1);
				out_clust_vis_idx[idx] = clust_inst_idx;

				// Ensure the WG size of element write indirect 
				atomicMax(param.write_vis_elem_cmd.num_groups_x, idx+1);

				// @TODO: Remove me
				/*
				if (ubo.late == 1) {
					atomicMax(debug.instance_late_count , idx + 1);
				}
				*/
			} else {
				// Write to cluster instance index in raster cluster list
				uint idx = atomicAdd(param.cluster_rast_count, 1);
				out_clust_rast_idx[idx] = clust_inst_idx;
				atomicMax(param.clust_raster_cmd.num_groups_x, idx+1);

				// @TODO: Remove me
				/*
				if (ubo.late == 1) {
					atomicMax(debug.instance_late_count , idx + 1);
				}
				*/
			}
		}
		else if (ubo.late == 0) {
			uint idx = atomicAdd(param.cluster_occ_count, 1);
			out_clust_occ_idx[idx] = clust_inst_idx;

			// Ensure WG size of cluster cull second pass
			uint req_wg_size = DIV_UP(idx+1, CLUSTER_CULL_LATE_GROUP_SIZE);
			atomicMax(param.clust_cull_late_cmd.num_groups_x, req_wg_size);
		}
	}
}