#version 460

#extension GL_ARB_shading_language_include : require
#include "common.h"

#extension GL_EXT_shader_image_int64 : require

#ifndef GROUP_SIZE
#define GROUP_SIZE 32
#endif

struct UniformData {
    mat4 world_to_view;
    mat4 world_to_view_normal;
    mat4 view_to_clip;
    mat4 clip_to_view;
    uint ortho;
    uint atom_mask;
};

layout (binding = 0, std140) uniform UboBuffer {
    UniformData ubo;
};

layout (location = 0) uniform uint sphere_count;

layout (binding = 0) readonly buffer PositionBuffer {
	Position positions[];
};

layout (binding = 1) readonly buffer RadiusBuffer {
	float radius[];
};

layout (binding = 0, r64ui) uniform uimage2D vis_img;

layout (local_size_x = GROUP_SIZE) in;

// From Arseny Kapoulkine (Niagara Project)
// https://github.com/zeux/niagara/blob/master/src/shaders/drawcull.comp.glsl
// 2D Polyhedral Bounds of a Clipped, Perspective-Projected 3D Sphere. Michael Mara, Morgan McGuire. 2013
void project_sphere(vec4 S, float P00, float P11, out vec4 aabb)
{
	vec2 cx = -S.xz;
	vec2 vx = vec2(sqrt(dot(cx, cx) - S.w * S.w), S.w);
	vec2 minx = mat2(vx.x, vx.y, -vx.y, vx.x) * cx;
	vec2 maxx = mat2(vx.x, -vx.y, vx.y, vx.x) * cx;

	vec2 cy = -S.yz;
	vec2 vy = vec2(sqrt(dot(cy, cy) - S.w * S.w), S.w);
	vec2 miny = mat2(vy.x, vy.y, -vy.y, vy.x) * cy;
	vec2 maxy = mat2(vy.x, -vy.y, vy.y, vy.x) * cy;

	aabb = vec4(minx.x / minx.y * P00, miny.x / miny.y * P11, maxx.x / maxx.y * P00, maxy.x / maxy.y * P11);
}

void main() {
	uint g_idx = gl_LocalInvocationIndex;
	uint l_idx = gl_LocalInvocationID.x;

	if (g_idx < sphere_count) {
		vec2 fle = vec2(0,0);
		vec4 view_sphere = spheres[g_idx];

		// NEAR CLIP
		// TODO

		vec2 axis_a, axis_b, center;
		float P00 = ubo.view_to_clip[0][0];
		float P11 = ubo.view_to_clip[1][1];
		vec4 clip_aabb;
		project_sphere(view_sphere, P00, P11, clip_aabb);

		vec4 uv_aabb = clip_aabb.xwzy * vec4(0.5f, -0.5f, 0.5f, -0.5f) + vec4(0.5f); // clip space -> uv space

		vec2  min_view_ext = vec2(view_bounds.x, view_bounds.z);
		vec2  max_view_ext = vec2(view_bounds.y, view_bounds.w);
		uvec2 min_texel_ext = uvec2(texel_bounds.x, texel_bounds.z);
		uvec2 max_texel_ext = uvec2(texel_bounds.y, texel_bounds.w);
		uint coverage = (max_texel_ext.x - min_texel_ext.x) * (max_texel_ext.y - min_texel_ext.y);

		if (coverage <= 1U) {
			// Write single pixel

		} else {
			// Rasterize box
			vec2 view_coord_delta = (max_view_ext - min_view_ext) / vec2(max(uvec2(1U), max_texel_ext - min_texel_ext));
			vec2 view_coord = min_view_ext;
		
			for (uint y = min_texel_ext.y; y < max_texel_ext.y; ++y) {
				for (uint x = min_texel_ext.x; x < max_texel_ext.x; ++x) {
					view_coord += view_coord_delta.x;
				}
				view_coord += view_coord_delta.y;
			}
		}
	}
}