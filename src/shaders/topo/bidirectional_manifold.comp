#version 450

#define WG_X 8
#define WG_Y 8
#define WG_Z 8
#define WG_SIZE (WG_X * WG_Y * WG_Z)

#define SG_X (WG_X + 2)
#define SG_Y (WG_Y + 2)
#define SG_Z (WG_Z + 2)
#define SG_SIZE (SG_X * SG_Y * SG_Z)

#define NUM_NEIGHBORS 26

// Use 3D workgroup size for natural grid mapping
layout(local_size_x = WG_X, local_size_y = WG_Y, local_size_z = WG_Z) in;

// UBO data (shared across all shaders)
layout(std140, binding = 0) uniform UBO {
    mat4  index_to_world;
    uvec3 dims;
    float scalar_threshold;
};
// Input volume texture
layout(binding = 0, r32f) uniform readonly image3D volumeTex;

// Output buffers: stores steepest neighbor index for each voxel
layout(std430, binding = 1) writeonly buffer AscendingManifold {
    uint ascending[];
};

layout(std430, binding = 2) writeonly buffer DescendingManifold {
    uint descending[];
};

// Shared memory for scalar values and voxel IDs in a 10x10x10 region (8x8x8 block + 1 padding in each direction)
shared float sharedScalars[SG_X][SG_Y][SG_Z];
shared uint sharedIds[SG_X][SG_Y][SG_Z];

// Helper functions
bool sos_is_greater(float value_a, uint id_a, float value_b, uint id_b) {
    return (value_a > value_b) || (value_a == value_b && id_a > id_b);
}

// Explicit neighbor offsets for 26-connectivity
const ivec3 neighbor_offset[NUM_NEIGHBORS] = ivec3[](
    ivec3(-1, -1, -1), ivec3(0, -1, -1), ivec3(1, -1, -1),
    ivec3(-1, 0, -1),  ivec3(0, 0, -1),  ivec3(1, 0, -1),
    ivec3(-1, 1, -1),  ivec3(0, 1, -1),  ivec3(1, 1, -1),
    
    ivec3(-1, -1, 0),  ivec3(0, -1, 0),  ivec3(1, -1, 0),
    ivec3(-1, 0, 0),                     ivec3(1, 0, 0),
    ivec3(-1, 1, 0),   ivec3(0, 1, 0),   ivec3(1, 1, 0),
    
    ivec3(-1, -1, 1),  ivec3(0, -1, 1),  ivec3(1, -1, 1),
    ivec3(-1, 0, 1),   ivec3(0, 0, 1),   ivec3(1, 0, 1),
    ivec3(-1, 1, 1),   ivec3(0, 1, 1),   ivec3(1, 1, 1)
);

void main() {
    // Compute global voxel index from 3D thread indices
    uvec3 gid = gl_GlobalInvocationID.xyz;
    if (any(greaterThanEqual(gid, dims))) {
        return;
    }
    uint i = gid.x + gid.y * dims.x + gid.z * dims.x * dims.y;
    ivec3 dims_i = ivec3(dims);
    ivec3 pos = ivec3(gid);

    // Compute local index inside shared 10x10x10 (offset by +1 for padding)
    ivec3 local_idx = ivec3(gl_LocalInvocationID) + ivec3(1);

    // Cooperative linear fill of the 10x10x10 shared region (covers centers + padding)
    int tid = int(gl_LocalInvocationIndex);

    // Block origin in voxel coordinates (position of the thread (0,0,0) in this WG) offset by -1 for padding
    ivec3 block_origin = ivec3(gl_WorkGroupID) * ivec3(WG_X, WG_Y, WG_Z) - ivec3(1);
    for (int s = tid; s < SG_SIZE; s += WG_SIZE) {
        int sx = s % SG_X;
        int sy = (s / SG_X) % SG_Y;
        int sz = s / (SG_X * SG_Y);

        // map shared slot to global voxel: block_origin
        ivec3 gp = block_origin + ivec3(sx, sy, sz);
        gp = clamp(gp, ivec3(0), dims_i - 1);

        sharedScalars[sx][sy][sz] = imageLoad(volumeTex, gp).r;
        int lin = gp.x + gp.y * dims_i.x + gp.z * dims_i.x * dims_i.y;
        sharedIds[sx][sy][sz] = uint(lin);
    }

    // Ensure all shared loads are visible
    barrier();

    float val = sharedScalars[local_idx.x][local_idx.y][local_idx.z];

    float max_val = val;
    float min_val = val;
    uint max_neighbor = i;
    uint min_neighbor = i;

    for (int j = 0; j < NUM_NEIGHBORS; j++) {
        ivec3 sidx = local_idx + neighbor_offset[j];
        float s = sharedScalars[sidx.x][sidx.y][sidx.z];
        uint  n = sharedIds[sidx.x][sidx.y][sidx.z];

        bool is_max = sos_is_greater(s, n, max_val, max_neighbor);
        bool is_min = sos_is_greater(min_val, min_neighbor, s, n);
        max_val      = is_max ? s : max_val;
        max_neighbor = is_max ? n : max_neighbor;
        min_val      = is_min ? s : min_val;
        min_neighbor = is_min ? n : min_neighbor;
    }

    ascending[i]  = max_neighbor;
    descending[i] = min_neighbor;
}