#version 430 core

#define QUANTIZATION_SCALE_FACTOR 1.0e6
#define MAX_POINTS 1024

// This is exposed as an image since we want to perform atomic float operations on it...
layout(binding = 0, r32f) readonly restrict uniform image3D in_vol;

layout (binding = 0, std430) readonly restrict buffer PointBuffer {
    vec4 in_points_geom[];
};

layout (binding = 1, std430) buffer ValueBuffer {
    uint out_values[];
};

layout(location = 0) uniform mat4 in_world_to_model;
layout(location = 1) uniform mat4 in_index_to_world;
layout(location = 2) uniform vec3 in_step;
layout(location = 3) uniform uint in_num_points;

shared uint  num_points;
shared vec4  point_geom[MAX_POINTS];
shared uint  point_idx[MAX_POINTS];
shared uint  point_values[MAX_POINTS];

layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;
void main() {
    uint thread_id = gl_LocalInvocationIndex;
    uint wg_size   = gl_WorkGroupSize.x * gl_WorkGroupSize.y * gl_WorkGroupSize.z;

    if (thread_id == 0) {
        num_points = 0;
    }
    for (uint i = thread_id; i < MAX_POINTS; i += wg_size) {
        point_values[i] = 0;
    }

    barrier();

    // Step 1: Load and test points against current block
    vec3 aabb_min = vec3( gl_WorkGroupID.xyz                 * gl_WorkGroupSize.xyz) * in_step;
    vec3 aabb_max = vec3((gl_WorkGroupID.xyz + uvec3(1,1,1)) * gl_WorkGroupSize.xyz) * in_step;

    for (uint i = thread_id; i < in_num_points; i += wg_size) {
        vec3 coord   = vec3(in_world_to_model * vec4(in_points_geom[i].xyz, 1.0));
        float radius = in_points_geom[i].w;
        vec3 clamped = clamp(coord, aabb_min, aabb_max);
        vec3 delta = clamped - coord;
        float r2 = dot(delta, delta);

        if (r2 < radius * radius) {
            // Push to workgroup GTOs
            uint idx = atomicAdd(num_points, 1);
            if (idx < MAX_POINTS) {
                point_geom[idx] = in_points_geom[i];
                point_idx[idx] = i;
            }   
        }
    }

    // Wait for all threads to add group shared points
    barrier();

    if (thread_id == 0) {
        num_points = min(num_points, MAX_POINTS);
    }
    barrier(); 

    ivec3 vol_idx = ivec3(gl_GlobalInvocationID.xyz);
    if (all(lessThan(vol_idx, imageSize(in_vol)))) {
        vec3 coord = vec3(in_index_to_world * vec4(vec3(vol_idx), 1.0));
        float val = imageLoad(in_vol, vol_idx).x;

        // Step 2: Find closest point (in the workgroup) for the coord and attribute to group index
        uint closest_idx = ~(0u);
        float closest_d2 = 1.0e20;
        for (uint i = 0; i < num_points; ++i) {
            vec4 pos_rad = point_geom[i];
            vec3 delta = coord - pos_rad.xyz;
            float d2 = dot(delta, delta) - pos_rad.w * pos_rad.w;

            if (d2 < closest_d2) {
                closest_d2  = d2;
                closest_idx = i;
            }
        }

        if (closest_idx < ~(0u)) {
            uint quantized_value = uint(round(val * QUANTIZATION_SCALE_FACTOR));
            atomicAdd(point_values[closest_idx], quantized_value);
        }
    }

    // Wait for all threads to write group values
    barrier();

    // Step 5: Write out results to global memory
    if (thread_id < num_points) {
        uint global_idx = point_idx[thread_id];
        atomicAdd(out_values[global_idx], point_values[thread_id]);
    }
}