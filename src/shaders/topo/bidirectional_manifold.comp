#version 450

// Use 3D workgroup size for natural grid mapping
layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

// UBO data (shared across all shaders)
layout(std140, binding = 0) uniform UBO {
    mat4  index_to_world;
    uvec3 dims;
    float scalar_threshold;
};
// Input volume texture
layout(binding = 0, r32f) uniform readonly image3D volumeTex;

// Output buffers: stores steepest neighbor index for each voxel
layout(std430, binding = 1) writeonly buffer AscendingManifold {
    uint ascending[];
};

layout(std430, binding = 2) writeonly buffer DescendingManifold {
    uint descending[];
};

// Shared memory for scalar values and voxel IDs in a 10x10x10 region (8x8x8 block + 1 padding in each direction)
shared float sharedScalars[10][10][10];
shared uint sharedIds[10][10][10];

bool sos_is_greater(float value_a, uint id_a, float value_b, uint id_b) {
    return (value_a > value_b) || (value_a == value_b && id_a > id_b);
}

float get_scalar(ivec3 ijk) {
    ivec3 dims_i = ivec3(dims);
    if (any(lessThan(ijk, ivec3(0))) || any(greaterThanEqual(ijk, dims_i))) {
        return 0.0;
    }
    return imageLoad(volumeTex, ijk).r;
}

void main() {
    // Compute global voxel index from 3D thread indices
    uvec3 gid = gl_GlobalInvocationID.xyz;
    if (any(greaterThanEqual(gid, dims))) {
        return;
    }
    uint i = gid.x + gid.y * dims.x + gid.z * dims.x * dims.y;
    ivec3 dims_i = ivec3(dims);
    ivec3 pos = ivec3(gid);

    // Compute local index inside shared 10x10x10 (offset by +1 for padding)
    ivec3 local_idx = ivec3(gl_LocalInvocationID) + ivec3(1);

    // Cooperative linear fill of the 10x10x10 shared region (covers centers + padding)
    {
        const int SG_X = 10;
        const int SG_Y = 10;
        const int SG_Z = 10;
        const int SG_SIZE = SG_X * SG_Y * SG_Z;
        // Use compile-time workgroup size constants to avoid driver compiler issues
        const ivec3 WG_SIZE = ivec3(8,8,8);
        const int WG_THREADS = 8 * 8 * 8;
        int tid = int(gl_LocalInvocationIndex);

        // Block origin in voxel coordinates (position of the thread (0,0,0) in this WG)
        ivec3 block_origin = ivec3(gl_WorkGroupID) * WG_SIZE;
        for (int s = tid; s < SG_SIZE; s += WG_THREADS) {
            int sx = s % SG_X;
            int sy = (s / SG_X) % SG_Y;
            int sz = s / (SG_X * SG_Y);

            // map shared slot to global voxel: block_origin + (sx-1, sy-1, sz-1)
            ivec3 gp = block_origin + ivec3(sx - 1, sy - 1, sz - 1);
            gp = clamp(gp, ivec3(0), dims_i - 1);

            sharedScalars[sx][sy][sz] = get_scalar(gp);
            int lin = gp.x + gp.y * dims_i.x + gp.z * dims_i.x * dims_i.y;
            sharedIds[sx][sy][sz] = uint(lin);
        }
    }

    // Ensure all shared loads are visible
    barrier();

    float val = sharedScalars[local_idx.x][local_idx.y][local_idx.z];

    //if (val < scalar_threshold) {
    //    ascending[i]  = 0xFFFFFFFFu;
    //    descending[i] = 0xFFFFFFFFu;
    //    return;
    //}

    float max_val = val;
    float min_val = val;
    uint max_neighbor = i;
    uint min_neighbor = i;

    // Explicit neighbor offsets for 26-connectivity
    const ivec3 neighbors[26] = ivec3[](
        ivec3(-1, -1, -1), ivec3(0, -1, -1), ivec3(1, -1, -1),
        ivec3(-1, 0, -1),  ivec3(0, 0, -1),  ivec3(1, 0, -1),
        ivec3(-1, 1, -1),  ivec3(0, 1, -1),  ivec3(1, 1, -1),
        
        ivec3(-1, -1, 0),  ivec3(0, -1, 0),  ivec3(1, -1, 0),
        ivec3(-1, 0, 0),                     ivec3(1, 0, 0),
        ivec3(-1, 1, 0),   ivec3(0, 1, 0),   ivec3(1, 1, 0),
        
        ivec3(-1, -1, 1),  ivec3(0, -1, 1),  ivec3(1, -1, 1),
        ivec3(-1, 0, 1),   ivec3(0, 0, 1),   ivec3(1, 0, 1),
        ivec3(-1, 1, 1),   ivec3(0, 1, 1),   ivec3(1, 1, 1)
    );

    for (int j = 0; j < 26; j++) {
        ivec3 npos = pos + neighbors[j];
        bool valid = all(greaterThanEqual(npos, ivec3(0))) && all(lessThan(npos, dims_i));
        if (!valid) {
            continue;
        }

        ivec3 sidx = local_idx + neighbors[j];
        // Read from shared memory (padding ensures sidx is in 0..9 range)
        float s = sharedScalars[sidx.x][sidx.y][sidx.z];
        uint  n = sharedIds[sidx.x][sidx.y][sidx.z];

        bool is_max = valid && sos_is_greater(s, n, max_val, max_neighbor);
        bool is_min = valid && sos_is_greater(min_val, min_neighbor, s, n);
        max_val      = is_max ? s : max_val;
        max_neighbor = is_max ? n : max_neighbor;
        min_val      = is_min ? s : min_val;
        min_neighbor = is_min ? n : min_neighbor;
    }

    ascending[i]  = max_neighbor;
    descending[i] = min_neighbor;
}